---
title: "LM3-PPA usage"
author: "Koen Hufkens"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{LM3-PPA usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(rsofun)
library(dplyr)
library(ggplot2)

pars <- list(par = c(
    kphio           = 0.04607080,
    soilm_par_a     = 2.75687824,
    soilm_par_b     = 1.68140444,
    tau_acclim_tempstress = 7.35259044,
    par_shape_tempstress  = 0.09863961
  ))
```

The `rsofun` package and framework includes two main models. The `pmodel` and `lm3-ppa` (which in part relies on pmodel component). Here we give a short example on how to run the `lm3ppa` model on the included demo datasets to familiarize yourself with both the data structure and the outputs.

## Demo data

The package includes two demo datasets to run and validate pmodel output. These files can be directly loaded into your workspace by typing:

```{r eval = FALSE}
library(rsofun)

lm3ppa_gs_leuning_drivers
lm3ppa_p_model_drivers
lm3ppa_validation
```

These are real data from the Swiss CH-Lae fluxnet site. We can use these data to run the model, together with observations of GPP we can also parameterize `lm3ppa` parameters.

# Two model approaches

The LM3-PPA is a cohort-based vegetation model which simulates vegetation dynamics and biogeochemical processes (Weng et al., 2015). The model is able to link photosynthesis standard models (Farquhar et al., 1980) with tree allometry. In our formulation we retain the original model structure with the standard photosynthesis formulation (i.e. "gs_leuning") as well as an alternative "p-model" approach. Both model structures operate at different time scales, where the original input has an hourly time step our alternative p-model approach uses a daily time step. Hence, we have two different datasets as driver data (with the lm3ppa p-model input being an aggregate of the high resolution hourly data).

## Running the LM3-PPA model with standard photosynthesis

With all data prepared we can run the model using `runread_lm3ppa_f()`. This function takes the nested data structure and runs the model site by site, returning nested model output results matching the input drivers. In our case only one site will be evaluated.

```{r}
# print parameter settings
print(lm3ppa_gs_leuning_drivers$params_siml)
print(head(lm3ppa_gs_leuning_drivers$forcing))
```

```{r eval = FALSE}
# run the model
lm3ppa_output_leuning <- runread_lm3ppa_f(
     lm3ppa_gs_leuning_drivers,
     makecheck = TRUE,
     parallel = FALSE
     )

# split out the annual data
lm3ppa_gs_leuning_output <- lm3ppa_gs_leuning_output$data[[1]]$output_annual_tile
```

### Plotting output

We can now visualize the model output.

```{r}
# we only have one site so we'll unnest
# the main model output

lm3ppa_gs_leuning_output %>% 
  ggplot() +
  geom_line(aes(x = year, y = GPP)) +
  theme_classic()+labs(x = "Year", y = "GPP")

lm3ppa_gs_leuning_output %>% 
  ggplot() +
  geom_line(aes(x = year, y = plantC)) +
  theme_classic()+labs(x = "Year", y = "plantC")
```

## Running the LM3-PPA model with P-model photosynthesis

Running the fast P-model implementation.

```{r}
# print parameter settings
print(lm3ppa_p_model_drivers$params_siml)
print(head(lm3ppa_p_model_drivers$forcing))
```
```{r eval = FALSE}
# run the model
lm3ppa_p_model_output <- runread_lm3ppa_f(
     lm3ppa_p_model_drivers,
     makecheck = TRUE,
     parallel = FALSE
     )

# split out the annual data for visuals
lm3ppa_p_model_output <- lm3ppa_p_model_output$data[[1]]$output_annual_tile
```

### Plotting output

We can now visualize the model output.

```{r}
# we only have one site so we'll unnest
# the main model output

lm3ppa_p_model_output %>% 
  ggplot() +
  geom_line(aes(x = year, y = GPP)) +
  theme_classic()+labs(x = "Year", y = "GPP")

lm3ppa_p_model_output %>% 
  ggplot() +
  geom_line(aes(x = year, y = plantC)) +
  theme_classic()+labs(x = "Year", y = "plantC")
```

## Calibrating model parameters

To optimize new parameters based upon driver data and a validation dataset we must first specify an optimization strategy and settings, as well as parameter ranges.

```{r eval = FALSE}
# Mortality as DBH
settings <- list(
  method              = "bayesiantools",
  targetvars          = c("gpp"),
  timescale           = list(targets_obs = "y"),
  sitenames           = "CH-Lae",
  metric              = cost_rmse_lm3ppa_gsleuning,
  dir_results         = "./",
  name                = "ORG",
  control = list(
    sampler = "DEzs",
    settings = list(
      burnin = 10,
      iterations = 50
    )
  ),
  par = list(
       phiRL = list(lower=0.5, upper=5, init=3.5),
      LAI_light = list(lower=2, upper=5, init=3.5),
      tf_base = list(lower=0.5, upper=1.5, init=1),
      par_mort = list(lower=0.1, upper=2, init=1))
)

pars <- calib_sofun(
  drivers = lm3ppa_gs_leuning_drivers,
  obs = lm3ppa_validation_2,
  settings = settings
)
```

